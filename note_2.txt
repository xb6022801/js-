...
组合实用原型模式和构造函数模式 : 构造函数定义实例属性，原型模式定义共享属性和方法
动态原型模式 (动态原型模式.js)
寄生构造函数模式 (寄生构造函数模式.js) : 和工厂模式很像。 不能用instanceof 来确定对象类型。不是特别推荐。应用场景: 实现拥有特殊方法的Array.
稳妥构造函数模式:禁止使用this，只能通过给定暴露方法来访问和修改数据。提供了一种安全性。

继承
关键: 子类通过 SubType.prototype = new SuperType() 来继承。且不能写在构造函数内部。(典型继承.js), 定义方法一定要放在替换原型之后
问题: 继承以后，父类实例的属性变成了子类原型对象的属性，被所有子类实例共享。 --> surtout pas!!; 所以实际中很少直接用原型继承。

方案一: 借用构造函数模式。问题: 并不能继承父类型原型对象的方法。导致函数复用不可行。 (继承_借用构造函数.js)
方案二: 组合继承: 原型继承 + 借用构造函数模式 (组合继承.js) --> 原型继承真正大量使用的典型方法。

原型式继承: (原型式继承.js)

Object.create(prototype, attributs): 依然会共享prototype的实例属性。

寄生式继承
组合寄生式继承 (组合寄生式继承.js) : 引用类型最理想的继承方式。

总结: section 6.4, p174