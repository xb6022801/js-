第21章 ajax与comet

XHR.open(method, url, isAsync)
open()只是启动一个请求，并不会真正发送。

XHR.send({ body } / null ) --> 真正发送。
return: responseText, responseXML (if content-type= "text/xml"), status, statusText

readyState // 0 1 2 3 4 --> readystatechange

设置自定义的请求头部信息: setRequestHeader(), 注: 在open 和 send 之间调用才行

GET请求: 每个parameter都需要用encodeURIComponent进行编码


XMLHttpRequest 2级内容:
FormData: var form = new FormData() //or form = new FormData(documents.forms[0])
超时限定: 只有ie8支持。 xhr.timeout = 1000 xhr.ontimeout = function() {}
overrideMimeType() 重写响应的mime类型，应用：如果返回xml而mime是text/plain，则responseXML为null，改写这个方法强制设置xml，
（必须在send之间）
进度事件：loadstart, progress, load, error, loadend
onload(event) || onprogress(event) //event.target = xhr
onprogress事件必须在open()方法前调用。

跨域
CORS （cross origin resource sharing, 跨源资源共享）：自定义http头部让浏览器和服务器之间沟通，从而决定是否响应请求。
client: origin: http://www.baidu.com
server: access-control-allow-origin: http://www.baidu.com
请求和响应都不包括cookie信息。

cors都是异步的，没有最后一个isAsync参数

IE8对cors的实现：XDR (XDomainRequest)
其他浏览器对cors的实现：直接用xhr就行。不用显式设置origin等。但是有一些限制：1.不能设置setRequestHeader() 2.不能设置cookie等。
为了消除歧义，对本站资源用相对url，对不同源的才用绝对url。

带凭据的请求: 如果发送的是带凭据带请求而响应中没有包含这个头部，则status = 0, responseText = empty, invoke onerror() event
client: withCredentials: true (IE10以及更早版本都不支持)
server: Allow-Control-Allow-Credentials: true

其他跨域技术：（都是在cors被广泛运用之前）
图像ping：最常用于跟踪用户点击页面或者动态广告曝光次数。缺点：只能发送GET，不能访问响应文本。
JSONP: json with padding （see server.js + testJsonp.js + index.html）
缺点: 如果响应中夹杂恶意代码，没有别的好的办法，只能放弃jsonp调用。2. 确定jsonp失败并不容易

comet：和ajax相反，comet是服务器向客户端推送。e.g. 长轮询 和 流。
长轮询：客户端发请求，服务器保持连接，有数据才发送响应，然后客户端立即再发请求。

websocket: ws:// or wss://
由于传递的数据包很小，很适合移动应用开发。
只能发送纯文本数据，所以需要JSON.stringify

SSE和微博socket的取舍:
- 是否有自由度建立和维护服务器，因为websocket需要升级服务器协议
- 是否需要双向通信，如果只是需要从服务器读取数据，用SSE就可以。

/*************************** end of chapter 21 *****************/
第7章: 函数表达式 (闭包，私有变量等)
函数声明 or 函数表达式
函数有name属性: alert(fn.name)

函数声明特性: 函数声明提升
函数表达式没有声明提升

递归函数中可以用arguments.callee来代替函数名，确保不会出问题。如果严格模式下，可以用命名函数表达式来达成相同成果。
(factorial.js)

闭包:
函数包括全局作用域+函数的执行作用域。执行完函数作用域被销毁。
闭包: 函数里的匿名函数，除了这2者之外，还包括父级函数的作用域，而父级函数由于还被引用，所以不会被销毁。
需要手动让匿名函数= null，就可以让该函数和父级函数被垃圾回收。
闭包因此会占用更多的内存。
闭包只能取得包含函数中任何变量的最后一个值。(闭包.js)

this对象: 通常情况下，全局情况下指向windows。在函数内指向执行函数的对象。
匿名函数的执行环境有全局性，this指向windows (经典问题。var that = this)

内存泄漏：
- IE：如果闭包的作用链中包含html元素，则该元素无法被销毁。
important: 闭包会饮用包含函数的整个活动对象

模仿块级作用域: 好处：不会污染全局作用域/父级作用域，减少内存开销 （私有作用域.js）

私有变量: arguments， local variables, 函数中定义的函数
可以创造可以访问私有变量的方法. （私有变量.js） 该模式的缺点是必须使用构造函数 （new fn()）,这将针对每个实例构造
一组新方法。not cool。 解决办法：静态私有变量。 (静态私有变量.js)

模块模式: 为单例创造私有变量和方法 (单例模式.js)
增加模块模式

/************************END OF CHAPTER 7 *********************************/

第四章： 变量，作用域和内存问题

基本类型和引用类型。
复制基本变量，实际上是复制值，两者是独立的

参数传递：基本类型和引用类型都是值传递。但是引用类型/对象在函数中属性被修改依然会体现出来（变量传递.js）

typeof null --> object
typeof undefined --> undefined

instanceof 检测是否为object，返回true。对基本类型返回false

执行环境：每个执行环境都有一个与之相关联点变量对象(variable object)
作用域链： scope chain
执行环境只有 全局 和 局部环境
延长作用域链方法: with or try/catch (with.js)

没有块级作用域 （{}: 举例： if语句，for循环中初始化的i （0到10），执行完以后还是10）
在函数里变量如果没有用var声明，则自动加入全局变量。

垃圾清理：找出不再使用的变量，然后释放其内存。
常用方法：标记清除 or 引用计数

IE的性能问题：IE的垃圾收集器是根据内存分配量运行的。
性能优化：全局变量和全局对象的属性，一旦不再有用，直接手动设置为null，以便垃圾回收，
globalVariable = null

/************************END OF CHAPTER 4 *********************************/
第六章：面向对象的程序设计

对象: 数据属性: [[configurable, enumerable, writable, value]]
Object.defineProperty(): 用该方法时，如果不指定，则configurable, enumerable, writable默认都是false

访问器属性： getters, setters
只指定getters意味着不能set value。

定一个attribut时数据属性或者访问器属性只能任选其一。
Object.getOwnPropertyDescriptor(Obj, attribut) 

设计模式：
工厂模式： 无需赘言
构造函数模式: 无需赘言, (大写开头)， 要创建新实例，必须要new操作符。new的过程执行了以下4个步骤：
- 新建对象
- 将函数作用域赋给对象
- 执行函数中的方法
- 返回对象

构造函数模式比工厂模式好，看（构造函数.js）
构造函数和普通函数没有任何区别，区别只是new 不 new
构造函数缺点： 每次新建实例都要新建内部函数

原型模式： 
每次新建实例，实例内部将包含一个指针指向构造函数的原型对象，初始情况下prototype只包含constructor
console.log(Person.prototype.isPrototypeOf(obj1)) //true
console.log(Object.getPrototypeOf(obj1))
实例不能overwrite原型上的值。但是可以在自己的实例上覆盖这个词。

in操作符： 所有enumerable = true的key都会显示, 
不管是否在原型或者实例上，都是true： console.log('name' in person1),
for..in: 对象上所有enumrable的属性，无论实例上或者原型上。
Object.keys(): 实例上所有enumerable属性
Object.getOwnPropertyNames(obj): 实例上无论enumerable与否的attribut，








