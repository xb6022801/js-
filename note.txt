第21章 ajax与comet

XHR.open(method, url, isAsync)
open()只是启动一个请求，并不会真正发送。

XHR.send({ body } / null ) --> 真正发送。
return: responseText, responseXML (if content-type= "text/xml"), status, statusText

readyState // 0 1 2 3 4 --> readystatechange

设置自定义的请求头部信息: setRequestHeader(), 注: 在open 和 send 之间调用才行

GET请求: 每个parameter都需要用encodeURIComponent进行编码


XMLHttpRequest 2级内容:
FormData: var form = new FormData() //or form = new FormData(documents.forms[0])
超时限定: 只有ie8支持。 xhr.timeout = 1000 xhr.ontimeout = function() {}
overrideMimeType() 重写响应的mime类型，应用：如果返回xml而mime是text/plain，则responseXML为null，改写这个方法强制设置xml，
（必须在send之间）
进度事件：loadstart, progress, load, error, loadend
onload(event) || onprogress(event) //event.target = xhr
onprogress事件必须在open()方法前调用。

跨域
CORS （cross origin resource sharing, 跨源资源共享）：自定义http头部让浏览器和服务器之间沟通，从而决定是否响应请求。
client: origin: http://www.baidu.com
server: access-control-allow-origin: http://www.baidu.com
请求和响应都不包括cookie信息。

cors都是异步的，没有最后一个isAsync参数

IE8对cors的实现：XDR (XDomainRequest)
其他浏览器对cors的实现：直接用xhr就行。不用显式设置origin等。但是有一些限制：1.不能设置setRequestHeader() 2.不能设置cookie等。
为了消除歧义，对本站资源用相对url，对不同源的才用绝对url。

带凭据的请求: 如果发送的是带凭据带请求而响应中没有包含这个头部，则status = 0, responseText = empty, invoke onerror() event
client: withCredentials: true (IE10以及更早版本都不支持)
server: Allow-Control-Allow-Credentials: true

其他跨域技术：（都是在cors被广泛运用之前）
图像ping：最常用于跟踪用户点击页面或者动态广告曝光次数。缺点：只能发送GET，不能访问响应文本。
JSONP: json with padding （see server.js + testJsonp.js + index.html）
缺点: 如果响应中夹杂恶意代码，没有别的好的办法，只能放弃jsonp调用。2. 确定jsonp失败并不容易

comet：和ajax相反，comet是服务器向客户端推送。e.g. 长轮询 和 流。
长轮询：客户端发请求，服务器保持连接，有数据才发送响应，然后客户端立即再发请求。

websocket: ws:// or wss://
由于传递的数据包很小，很适合移动应用开发。
只能发送纯文本数据，所以需要JSON.stringify

SSE和微博socket的取舍:
- 是否有自由度建立和维护服务器，因为websocket需要升级服务器协议
- 是否需要双向通信，如果只是需要从服务器读取数据，用SSE就可以。

/*************************** end of chapter 21 *****************/
第7章: 函数表达式 (闭包，私有变量等)
函数声明 or 函数表达式
函数有name属性: alert(fn.name)

函数声明特性: 函数声明提升
函数表达式没有声明提升

递归函数中可以用arguments.callee来代替函数名，确保不会出问题。如果严格模式下，可以用命名函数表达式来达成相同成果。
(factorial.js)

闭包:
函数包括全局作用域+函数的执行作用域。执行完函数作用域被销毁。
闭包: 函数里的匿名函数，除了这2者之外，还包括父级函数的作用域，而父级函数由于还被引用，所以不会被销毁。
需要手动让匿名函数= null，就可以让该函数和父级函数被垃圾回收。
闭包因此会占用更多的内存。
闭包只能取得包含函数中任何变量的最后一个值。(闭包.js)

this对象: 通常情况下，全局情况下指向windows。在函数内指向执行函数的对象。
匿名函数的执行环境有全局性，this指向windows (经典问题。var that = this)

to be continued at 内存泄漏


